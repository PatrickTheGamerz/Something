<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Players – Sans Duel Setup</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f0f13;
      --panel: #171a22;
      --accent: #7cf0ff;
      --accent2: #e9a6ff;
      --text: #e8ecf1;
      --muted: #9aa3ad;
      --danger: #ff6b6b;
      --ok: #7dffb7;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 60% 20%, #13151d 0%, var(--bg) 55%, #0b0c10 100%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    header {
      padding: 24px;
      text-align: center;
    }
    h1 {
      margin: 0;
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap: 20px;
      padding: 24px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .card {
      background: linear-gradient(180deg, #1b1f2a 0%, var(--panel) 100%);
      border: 1px solid #242837;
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.06em;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }
    label {
      display: block;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #2c3244;
      background: #141824;
      color: var(--text);
      outline: none;
    }
    input[type="color"] {
      width: 100%;
      height: 38px;
      border-radius: 10px;
      border: 1px solid #2c3244;
      background: #141824;
      padding: 0;
    }
    .kbd {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #121622;
      border: 1px solid #2a3044;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.85rem;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    .hint {
      color: var(--muted);
      font-size: 0.85rem;
      margin-top: 2px;
    }
    .actions {
      display: flex;
      gap: 12px;
      padding: 24px;
      max-width: 1100px;
      margin: 0 auto;
      justify-content: flex-end;
    }
    button {
      appearance: none;
      border: none;
      background: linear-gradient(180deg, #1f8cff 0%, #1273ff 100%);
      color: white;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(18,115,255,0.35);
    }
    button.secondary {
      background: linear-gradient(180deg, #3b3f54 0%, #2a2e42 100%);
      color: #cfd6e4;
      box-shadow: none;
      border: 1px solid #2f3549;
    }
    .preview {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 10px;
    }
    .sprite {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      outline: 2px solid #ffffff;
      box-shadow: 0 0 10px rgba(255,255,255,0.65);
    }
    footer {
      padding: 20px;
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }
    .tiny {
      font-size: 0.8rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Sans Duel – Player setup</h1>
    <p class="hint">Local two‑player fight. Configure names, colors, and options, then start the duel.</p>
  </header>

  <section class="grid">
    <div class="card" id="p1card">
      <h2>Player one</h2>
      <div class="row">
        <div>
          <label for="p1name">Name</label>
          <input type="text" id="p1name" placeholder="Player One" value="Player One" />
        </div>
        <div>
          <label for="p1color">Color</label>
          <input type="color" id="p1color" value="#7cf0ff" />
        </div>
      </div>
      <div>
        <label>Controls</label>
        <div class="controls">
          <div class="kbd"><strong>Move:</strong> W A S D</div>
          <div class="kbd"><strong>Dash:</strong> R</div>
          <div class="kbd"><strong>Bone shot:</strong> F</div>
          <div class="kbd"><strong>Blaster:</strong> G</div>
        </div>
        <p class="hint">Hold movement for continuous motion. Attacks have cooldowns and cost stamina.</p>
      </div>
      <div class="preview">
        <div class="sprite" id="p1sprite"></div>
        <span class="tiny">Preview</span>
      </div>
    </div>

    <div class="card" id="p2card">
      <h2>Player two</h2>
      <div class="row">
        <div>
          <label for="p2name">Name</label>
          <input type="text" id="p2name" placeholder="Player Two" value="Player Two" />
        </div>
        <div>
          <label for="p2color">Color</label>
          <input type="color" id="p2color" value="#e9a6ff" />
        </div>
      </div>
      <div>
        <label>Controls</label>
        <div class="controls">
          <div class="kbd"><strong>Move:</strong> Arrow Keys</div>
          <div class="kbd"><strong>Dash:</strong> P</div>
          <div class="kbd"><strong>Bone shot:</strong> K</div>
          <div class="kbd"><strong>Blaster:</strong> L</div>
        </div>
        <p class="hint">Blaster beams telegraph briefly before firing. Dash grants short i‑frames.</p>
      </div>
      <div class="preview">
        <div class="sprite" id="p2sprite"></div>
        <span class="tiny">Preview</span>
      </div>
    </div>

    <div class="card">
      <h2>Options</h2>
      <div class="row">
        <div>
          <label for="roundTime">Round time (seconds)</label>
          <input type="number" id="roundTime" min="15" max="300" step="5" value="90" />
        </div>
        <div>
          <label for="damageScale">Damage scale (0.5–2.0)</label>
          <input type="number" id="damageScale" min="0.5" max="2" step="0.1" value="1.0" />
        </div>
      </div>
      <div class="row">
        <div>
          <label for="dashIframes">Dash i‑frames (ms)</label>
          <input type="number" id="dashIframes" min="0" max="600" step="50" value="250" />
        </div>
        <div>
          <label for="staminaRegen">Stamina regen (per second)</label>
          <input type="number" id="staminaRegen" min="10" max="200" step="5" value="60" />
        </div>
      </div>
      <div class="row">
        <div>
          <label for="arenaScale">Arena scale (0.8–1.4)</label>
          <input type="number" id="arenaScale" min="0.8" max="1.4" step="0.1" value="1.0" />
        </div>
        <div>
          <label for="suddenDeath">Sudden death at 0:00</label>
          <select id="suddenDeath">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
      </div>
      <p class="hint">Damage scale affects all attacks. Sudden death raises damage and reduces i‑frames in the final 15 seconds.</p>
    </div>

    <div class="card">
      <h2>About</h2>
      <p>This duel is inspired by “Sans‑style” attacks: bones and blasters, quick dashes, tight timing. Pure HTML5 canvas, no external assets.</p>
      <p class="hint">Tip: Keep colors high‑contrast for visibility. If you want mirror‑match aesthetics, use similar hues with different outlines.</p>
    </div>
  </section>

  <div class="actions">
    <button class="secondary" id="resetBtn">Reset</button>
    <button id="startBtn">Start fight</button>
  </div>

  <footer>
    <span class="tiny">Local multiplayer. Best played on desktop keyboard.</span>
  </footer>

  <script>
    const p1name = document.getElementById('p1name');
    const p2name = document.getElementById('p2name');
    const p1color = document.getElementById('p1color');
    const p2color = document.getElementById('p2color');
    const p1sprite = document.getElementById('p1sprite');
    const p2sprite = document.getElementById('p2sprite');

    const roundTime = document.getElementById('roundTime');
    const damageScale = document.getElementById('damageScale');
    const dashIframes = document.getElementById('dashIframes');
    const staminaRegen = document.getElementById('staminaRegen');
    const arenaScale = document.getElementById('arenaScale');
    const suddenDeath = document.getElementById('suddenDeath');

    function applyPreview() {
      p1sprite.style.background = p1color.value;
      p2sprite.style.background = p2color.value;
    }
    [p1color, p2color].forEach(el => el.addEventListener('input', applyPreview));
    applyPreview();

    document.getElementById('resetBtn').addEventListener('click', () => {
      p1name.value = 'Player One';
      p2name.value = 'Player Two';
      p1color.value = '#7cf0ff';
      p2color.value = '#e9a6ff';
      roundTime.value = 90;
      damageScale.value = 1.0;
      dashIframes.value = 250;
      staminaRegen.value = 60;
      arenaScale.value = 1.0;
      suddenDeath.value = 'on';
      applyPreview();
      localStorage.removeItem('sans_duel_settings');
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      const settings = {
        p1: { name: p1name.value.trim() || 'Player One', color: p1color.value },
        p2: { name: p2name.value.trim() || 'Player Two', color: p2color.value },
        opts: {
          roundTime: Math.max(15, Math.min(300, Number(roundTime.value))),
          damageScale: Math.max(0.5, Math.min(2.0, Number(damageScale.value))),
          dashIframes: Math.max(0, Math.min(600, Number(dashIframes.value))),
          staminaRegen: Math.max(10, Math.min(200, Number(staminaRegen.value))),
          arenaScale: Math.max(0.8, Math.min(1.4, Number(arenaScale.value))),
          suddenDeath: suddenDeath.value === 'on'
        }
      };
      localStorage.setItem('sans_duel_settings', JSON.stringify(settings));
      window.location.href = 'Tower.html';
    });
  </script>
</body>
</html>

(Players)











































<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tower – Sans Duel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #141927;
      --line: #232a3d;
      --text: #e8ecf1;
      --muted: #a9b2bf;
      --danger: #ff6b6b;
      --ok: #7dffb7;
      --warn: #ffd66b;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 50% 20%, #13151d 0%, var(--bg) 55%, #0b0c10 100%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      overflow: hidden;
    }
    header {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(12,15,20,0.85) 0%, rgba(12,15,20,0.35) 100%);
      border-bottom: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(6px);
      z-index: 3;
    }
    .hud {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .bar {
      width: clamp(160px, 22vw, 260px);
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #101420;
      padding: 8px;
    }
    .bar .name {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .bar .hpbg, .bar .stbg {
      width: 100%;
      height: 12px;
      border-radius: 6px;
      background: #0d1120;
      border: 1px solid #1c2235;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .bar .hpfg, .bar .stfg {
      height: 100%;
      width: 100%;
      border-radius: 6px;
      transition: width 0.12s ease-out;
    }
    .bar .hpfg { background: linear-gradient(90deg, var(--ok), #5ceecc); }
    .bar .stfg { background: linear-gradient(90deg, #6b8aff, #a6b6ff); }
    .timer {
      font-weight: 800;
      letter-spacing: 0.05em;
      font-variant-numeric: tabular-nums;
    }
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 0.85rem;
    }
    .kbd {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #121622;
      border: 1px solid #2a3044;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.85rem;
    }
    canvas {
      position: absolute;
      inset: 0;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 4;
      pointer-events: none;
    }
    .centerCard {
      background: linear-gradient(180deg, rgba(20,25,40,0.85) 0%, rgba(16,20,32,0.75) 100%);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 16px 20px;
      text-align: center;
      backdrop-filter: blur(6px);
      min-width: 300px;
      pointer-events: auto;
    }
    .title {
      font-weight: 900;
      font-size: 1.3rem;
      margin: 6px 0 10px;
    }
    .sub {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 10px;
    }
    .buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 8px;
    }
    button {
      appearance: none;
      border: none;
      background: linear-gradient(180deg, #1f8cff 0%, #1273ff 100%);
      color: white;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(18,115,255,0.35);
    }
    button.secondary {
      background: linear-gradient(180deg, #3b3f54 0%, #2a2e42 100%);
      color: #cfd6e4;
      box-shadow: none;
      border: 1px solid #2f3549;
    }
    .countdown {
      font-size: 3rem;
      font-weight: 900;
      color: white;
      text-shadow: 0 0 20px rgba(255,255,255,0.35);
    }
  </style>
</head>
<body>
  <header>
    <div class="hud">
      <div class="bar" id="p1bar">
        <div class="name"><span id="p1name">P1</span><span id="p1hpLabel">100</span></div>
        <div class="hpbg"><div class="hpfg" id="p1hp"></div></div>
        <div class="stbg"><div class="stfg" id="p1st"></div></div>
      </div>
      <div class="bar" id="p2bar">
        <div class="name"><span id="p2name">P2</span><span id="p2hpLabel">100</span></div>
        <div class="hpbg"><div class="hpfg" id="p2hp"></div></div>
        <div class="stbg"><div class="stfg" id="p2st"></div></div>
      </div>
    </div>
    <div class="legend">
      <span class="timer" id="timer">90</span>
      <span class="kbd"><strong>P1:</strong> WASD • F Bone • G Blaster • R Dash</span>
      <span class="kbd"><strong>P2:</strong> Arrows • K Bone • L Blaster • P Dash</span>
      <span class="kbd"><strong>Pause:</strong> Space</span>
    </div>
  </header>

  <canvas id="game"></canvas>

  <div class="overlay" id="overlay" style="display:none;">
    <div class="centerCard">
      <div class="title" id="overlayTitle">Paused</div>
      <div class="sub" id="overlaySub">Press Space to resume</div>
      <div class="buttons">
        <button id="resumeBtn">Resume</button>
        <button class="secondary" id="rematchBtn">Rematch</button>
        <button class="secondary" id="setupBtn">Setup</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="countOverlay">
    <div class="countdown" id="countText">3</div>
  </div>

  <script>
    // Settings load
    const defaults = {
      p1: { name: 'Player One', color: '#7cf0ff' },
      p2: { name: 'Player Two', color: '#e9a6ff' },
      opts: {
        roundTime: 90, damageScale: 1.0, dashIframes: 250,
        staminaRegen: 60, arenaScale: 1.0, suddenDeath: true
      }
    };
    let settings;
    try {
      settings = JSON.parse(localStorage.getItem('sans_duel_settings')) || defaults;
    } catch {
      settings = defaults;
    }
    const opts = settings.opts;

    // HUD apply
    document.getElementById('p1name').textContent = settings.p1.name;
    document.getElementById('p2name').textContent = settings.p2.name;
    document.getElementById('p1bar').style.borderColor = settings.p1.color;
    document.getElementById('p2bar').style.borderColor = settings.p2.color;

    // Canvas setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize() {
      const scale = opts.arenaScale || 1.0;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.width = Math.floor(w);
      canvas.height = Math.floor(h);
      // Arena margins to avoid UI overlap
      arena.bounds = {
        x: Math.floor(w * 0.05),
        y: Math.floor(h * 0.12),
        w: Math.floor(w * 0.90),
        h: Math.floor(h * 0.80 * scale)
      };
      arena.floorY = arena.bounds.y + arena.bounds.h - 20;
    }
    window.addEventListener('resize', resize);

    // Core game state
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      keys.add(e.key.toLowerCase());
      if (e.key === ' ') {
        e.preventDefault();
        togglePause();
      }
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    const arena = {
      bounds: { x: 0, y: 0, w: 0, h: 0 },
      floorY: 0,
      gravity: 1500,
      friction: 0.86
    };

    class Player {
      constructor(idx, name, color, controls) {
        this.idx = idx;
        this.name = name;
        this.color = color;
        this.controls = controls;
        this.reset();
      }
      reset() {
        const b = arena.bounds;
        this.radius = 16;
        this.x = this.idx === 1 ? b.x + b.w * 0.25 : b.x + b.w * 0.75;
        this.y = arena.floorY - this.radius;
        this.vx = 0; this.vy = 0;
        this.speed = 280;
        this.jump = 520;
        this.hp = 100;
        this.stamina = 100;
        this.maxStamina = 100;
        this.iframes = 0;
        this.invFlash = 0;
        this.facing = this.idx === 1 ? 1 : -1;
        this.cooldowns = { bone: 0, blaster: 0, dash: 0 };
        this.grounded = true;
        this.dead = false;
        this.nameTag = this.name;
      }
      input(dt) {
        if (this.dead) return;
        // Movement
        const left = keys.has(this.controls.left);
        const right = keys.has(this.controls.right);
        const up = keys.has(this.controls.up);
        const down = keys.has(this.controls.down);

        let axisX = 0;
        if (left) axisX -= 1;
        if (right) axisX += 1;
        this.vx += axisX * this.speed * dt;
        if (Math.abs(this.vx) > this.speed) {
          this.vx = this.speed * Math.sign(this.vx);
        }
        if (axisX !== 0) this.facing = axisX;

        // Jump (optional small hop to give vertical spice)
        if (up && this.grounded) {
          this.vy = -this.jump;
          this.grounded = false;
        }

        // Actions
        if (keys.has(this.controls.bone) && this.cooldowns.bone <= 0 && this.stamina >= 15) {
          this.fireBone();
        }
        if (keys.has(this.controls.blaster) && this.cooldowns.blaster <= 0 && this.stamina >= 35) {
          this.fireBlaster();
        }
        if (keys.has(this.controls.dash) && this.cooldowns.dash <= 0 && this.stamina >= 25) {
          this.dash();
        }
      }
      dash() {
        this.stamina -= 25;
        this.cooldowns.dash = 0.65; // seconds
        const power = 520 * (this.facing || 1);
        this.vx = power;
        this.iframes = opts.dashIframes / 1000; // seconds
        this.invFlash = this.iframes;
      }
      fireBone() {
        this.stamina -= 15;
        this.cooldowns.bone = 0.35;
        const speed = 600;
        const spread = (Math.random() * 0.20 - 0.10); // slight aim variance
        const vx = speed * (this.facing || 1);
        const vy = spread * speed;
        const bone = {
          type: 'bone',
          x: this.x + (this.radius + 6) * (this.facing || 1),
          y: this.y - this.radius * 0.25,
          vx, vy,
          r: 6,
          owner: this.idx,
          life: 1.6
        };
        projectiles.push(bone);
      }
      fireBlaster() {
        this.stamina -= 35;
        this.cooldowns.blaster = 2.0;
        // Telegraph beam then fire
        const beam = {
          type: 'blaster',
          owner: this.idx,
          x: this.x + (this.facing || 1) * (this.radius + 8),
          y: this.y - this.radius * 0.4,
          dir: this.facing || 1,
          tele: 0.45, // telegraph seconds
          fire: 0.35, // active seconds
          width: 12
        };
        projectiles.push(beam);
      }
      physics(dt) {
        if (this.dead) return;
        // Cooldowns and timers
        for (const k in this.cooldowns) {
          if (this.cooldowns[k] > 0) this.cooldowns[k] -= dt;
          if (this.cooldowns[k] < 0) this.cooldowns[k] = 0;
        }
        if (this.iframes > 0) this.iframes -= dt;
        if (this.invFlash > 0) this.invFlash -= dt;

        // Regen stamina
        this.stamina = Math.min(this.maxStamina, this.stamina + opts.staminaRegen * dt);

        // Gravity
        this.vy += arena.gravity * dt;
        // Friction
        this.vx *= arena.friction;

        // Integrate
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Collide with floor and walls
        const b = arena.bounds;
        // Floor
        const floor = arena.floorY - this.radius;
        if (this.y >= floor) {
          this.y = floor;
          this.vy = 0;
          this.grounded = true;
        }

        // Walls
        const left = b.x + this.radius;
        const right = b.x + b.w - this.radius;
        if (this.x < left) { this.x = left; this.vx = Math.max(0, this.vx); }
        if (this.x > right) { this.x = right; this.vx = Math.min(0, this.vx); }
      }
      damage(amount, sourceDir) {
        if (this.dead) return;
        if (this.iframes > 0) return;
        const scale = suddenDeathActive ? opts.damageScale * 1.35 : opts.damageScale;
        const dmg = Math.round(amount * scale);
        this.hp -= dmg;
        this.iframes = 0.25; // small post‑hit protection
        this.invFlash = 0.25;
        // Knockback
        this.vx += (sourceDir || 0) * 240;
        this.vy -= 180;
        if (this.hp <= 0) {
          this.hp = 0;
          this.dead = true;
        }
      }
      draw(ctx) {
        // Body (simple glow circle)
        ctx.save();
        // I‑frame flash
        const flashing = this.invFlash > 0 && Math.floor(perf * 10) % 2 === 0;
        const baseColor = flashing ? '#ffffff' : this.color;

        // Glow
        ctx.shadowColor = baseColor;
        ctx.shadowBlur = 18;
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Outline
        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius + 1.5, 0, Math.PI * 2);
        ctx.stroke();

        // Eyes (minimal Sans vibe)
        ctx.fillStyle = '#ffffff';
        const eyeOffset = 6;
        ctx.beginPath();
        ctx.arc(this.x + (eyeOffset) * this.facing, this.y - 6, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + (-eyeOffset) * this.facing, this.y - 6, 3.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    // Controls mapping
    const p1controls = { left: 'a', right: 'd', up: 'w', down: 's', bone: 'f', blaster: 'g', dash: 'r' };
    const p2controls = { left: 'arrowleft', right: 'arrowright', up: 'arrowup', down: 'arrowdown', bone: 'k', blaster: 'l', dash: 'p' };

    const p1 = new Player(1, settings.p1.name, settings.p1.color, p1controls);
    const p2 = new Player(2, settings.p2.name, settings.p2.color, p2controls);

    // Projectiles
    const projectiles = [];

    // Timer
    let timeLeft = opts.roundTime;
    let paused = true;
    let suddenDeathActive = false;

    // HUD elements
    const p1hpEl = document.getElementById('p1hp');
    const p1stEl = document.getElementById('p1st');
    const p2hpEl = document.getElementById('p2hp');
    const p2stEl = document.getElementById('p2st');
    const p1hpLabel = document.getElementById('p1hpLabel');
    const p2hpLabel = document.getElementById('p2hpLabel');
    const timerEl = document.getElementById('timer');

    // Overlay controls
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlaySub = document.getElementById('overlaySub');
    const resumeBtn = document.getElementById('resumeBtn');
    const rematchBtn = document.getElementById('rematchBtn');
    const setupBtn = document.getElementById('setupBtn');

    resumeBtn.addEventListener('click', () => setPaused(false));
    rematchBtn.addEventListener('click', () => {
      resetRound();
      startCountdown();
    });
    setupBtn.addEventListener('click', () => {
      window.location.href = 'Players.html';
    });

    function togglePause() { setPaused(!paused); }
    function setPaused(v) {
      paused = v;
      overlay.style.display = v ? 'grid' : 'none';
      overlayTitle.textContent = p1.dead || p2.dead ? 'Round over' : (v ? 'Paused' : 'Running');
      overlaySub.textContent = p1.dead || p2.dead
        ? 'Rematch or go back to setup.'
        : (v ? 'Press Space to resume' : '');
    }

    // Countdown
    const countOverlay = document.getElementById('countOverlay');
    const countText = document.getElementById('countText');
    function startCountdown() {
      paused = true;
      countOverlay.style.display = 'grid';
      overlay.style.display = 'none';
      let c = 3;
      countText.textContent = c;
      const int = setInterval(() => {
        c--;
        if (c <= 0) {
          clearInterval(int);
          countOverlay.style.display = 'none';
          setPaused(false);
        } else {
          countText.textContent = c;
        }
      }, 700);
    }

    // Utility
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Projectile logic and drawing
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        if (p.type === 'bone') {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += arena.gravity * 0.15 * dt; // slight drop
          p.life -= dt;
          // Collide with arena walls
          const b = arena.bounds;
          if (p.x < b.x || p.x > b.x + b.w || p.y > b.y + b.w) p.life = 0;
          // Hit players
          const targets = p.owner === 1 ? [p2] : [p1];
          for (const t of targets) {
            const dx = t.x - p.x;
            const dy = t.y - p.y;
            const dist = Math.hypot(dx, dy);
            if (dist < t.radius + p.r) {
              t.damage(10, Math.sign(dx) * -1);
              p.life = 0;
              break;
            }
          }
          if (p.life <= 0) projectiles.splice(i, 1);
        } else if (p.type === 'blaster') {
          if (p.tele > 0) {
            p.tele -= dt;
            if (p.tele <= 0) {
              // Fire phase begins
            }
          } else if (p.fire > 0) {
            p.fire -= dt;
            // Beam collision sweep
            const length = 220;
            const width = p.width;
            const x1 = p.x;
            const y1 = p.y;
            const x2 = p.x + p.dir * length;
            const y2 = p.y;
            const targets = p.owner === 1 ? [p2] : [p1];
            for (const t of targets) {
              // Distance from point to segment (axis‑aligned horizontal)
              const nearX = clamp(t.x, Math.min(x1, x2), Math.max(x1, x2));
              const nearY = t.y;
              const dist = Math.hypot(nearX - t.x, nearY - y1);
              if (dist < t.radius + width) {
                t.damage(20, p.dir);
              }
            }
            if (p.fire <= 0) projectiles.splice(i, 1);
          }
        }
      }
    }

    function drawArena() {
      const b = arena.bounds;
      // Background
      ctx.fillStyle = '#0c0f14';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Arena panel
      ctx.save();
      ctx.shadowColor = '#000000';
      ctx.shadowBlur = 24;
      const grad = ctx.createLinearGradient(0, b.y, 0, b.y + b.h);
      grad.addColorStop(0, '#101526');
      grad.addColorStop(1, '#0b0e18');
      ctx.fillStyle = grad;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.restore();

      // Floor line
      ctx.strokeStyle = '#2a3147';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x + 6, arena.floorY + 1.5);
      ctx.lineTo(b.x + b.w - 6, arena.floorY + 1.5);
      ctx.stroke();

      // Subtle grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let x = b.x + 20; x < b.x + b.w; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, b.y + 10);
        ctx.lineTo(x, b.y + b.h - 10);
        ctx.stroke();
      }
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        if (p.type === 'bone') {
          ctx.save();
          ctx.shadowColor = '#ffffff';
          ctx.shadowBlur = 10;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
          // tiny spine line
          ctx.strokeStyle = '#dfe6ff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x - p.r * 0.8, p.y);
          ctx.lineTo(p.x + p.r * 0.8, p.y);
          ctx.stroke();
          ctx.restore();
        } else if (p.type === 'blaster') {
          // Telegraph
          if (p.tele > 0) {
            ctx.save();
            ctx.strokeStyle = '#64d2ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.dir * 220, p.y);
            ctx.stroke();
            ctx.restore();
          } else if (p.fire > 0) {
            // Beam
            ctx.save();
            const grad = ctx.createLinearGradient(p.x, p.y, p.x + p.dir * 220, p.y);
            grad.addColorStop(0, '#b0f5ff');
            grad.addColorStop(1, '#64d2ff');
            ctx.strokeStyle = grad;
            ctx.lineWidth = p.width * 2;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.dir * 220, p.y);
            ctx.stroke();
            // Core line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = p.width;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.dir * 220, p.y);
            ctx.stroke();
            ctx.restore();
          }
        }
      }
    }

    // Round control
    function resetRound() {
      p1.reset(); p2.reset();
      projectiles.length = 0;
      timeLeft = opts.roundTime;
      suddenDeathActive = false;
      updateHUD();
    }

    function updateHUD() {
      p1hpEl.style.width = p1.hp + '%';
      p2hpEl.style.width = p2.hp + '%';
      p1stEl.style.width = (p1.stamina) + '%';
      p2stEl.style.width = (p2.stamina) + '%';
      p1hpLabel.textContent = Math.round(p1.hp);
      p2hpLabel.textContent = Math.round(p2.hp);
      timerEl.textContent = Math.max(0, Math.ceil(timeLeft));
    }

    // Game loop
    let last = performance.now();
    let perf = 0;

    function step(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      perf = now / 1000;

      if (!paused) {
        timeLeft -= dt;
        if (opts.suddenDeath && timeLeft <= 15) {
          suddenDeathActive = true;
        }
        // Inputs
        p1.input(dt);
        p2.input(dt);

        // Physics
        p1.physics(dt);
        p2.physics(dt);

        // Projectiles
        updateProjectiles(dt);

        // Check deaths
        if ((p1.dead || p2.dead) && !paused) {
          paused = true;
          overlay.style.display = 'grid';
          const winner = p1.dead && p2.dead ? 'Draw!' : (p1.dead ? `${p2.name} wins!` : `${p1.name} wins!`);
          overlayTitle.textContent = winner;
          overlaySub.textContent = 'Rematch or go back to setup.';
        }

        // Timeout sudden death: if time hits 0, apply tie‑breaker (lowest HP loses)
        if (timeLeft <= 0 && !paused) {
          paused = true;
          overlay.style.display = 'grid';
          let winner;
          if (Math.abs(p1.hp - p2.hp) <= 0.001) winner = 'Draw!';
          else winner = p1.hp > p2.hp ? `${p1.name} wins (time)!` : `${p2.name} wins (time)!`;
          overlayTitle.textContent = winner;
          overlaySub.textContent = 'Rematch or go back to setup.';
        }

        updateHUD();
      }

      // Render
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawArena();
      drawProjectiles();
      p1.draw(ctx);
      p2.draw(ctx);

      requestAnimationFrame(step);
    }

    // Init
    resize();
    resetRound();
    startCountdown();
    requestAnimationFrame(step);
  </script>
</body>
</html>

(Tower)
